//Round Robin
import java.util.Scanner;  
public class RoundRobin  
{  
public static void main(String args[])  
{  
int n,i,qt,count=0,temp,sq=0,bt[],wt[],tat[],rem_bt[];  
float awt=0,atat=0;  
bt = new int[10];  
wt = new int[10];  
tat = new int[10];  
rem_bt = new int[10];  
Scanner s=new Scanner(System.in);  
System.out.print("Enter the number of process (maximum 10) = ");  
n = s.nextInt();  
System.out.print("Enter the burst time of the process\n");  
for (i=0;i<n;i++)  
{  
System.out.print("P"+i+" = ");   
bt[i] = s.nextInt();  
rem_bt[i] = bt[i];  
}  
System.out.print("Enter the quantum time: ");  
qt = s.nextInt();  
while(true)  
{  
for (i=0,count=0;i<n;i++)  
{  
temp = qt;  
if(rem_bt[i] == 0)  
{  
count++;  
continue;  
}  
if(rem_bt[i]>qt)  
rem_bt[i]= rem_bt[i] - qt;  
else  
if(rem_bt[i]>=0)  
{  
temp = rem_bt[i];  
rem_bt[i] = 0;  
}  
sq = sq + temp;  
tat[i] = sq;  
}  
if(n == count)  
break;  
}  
System.out.print("--------------------------------------------------------------------------------");  
System.out.print("\nProcess\t      Burst Time\t       Turnaround Time\t          Waiting Time\n");  
System.out.print("--------------------------------------------------------------------------------");  
for(i=0;i<n;i++)  
{  
wt[i]=tat[i]-bt[i];  
awt=awt+wt[i];  
atat=atat+tat[i];  
System.out.print("\n "+(i+1)+"\t "+bt[i]+"\t\t "+tat[i]+"\t\t "+wt[i]+"\n");  
}  
awt=awt/n;  
atat=atat/n;  
System.out.println("\nAverage waiting Time = "+awt+"\n");  
System.out.println("Average turnaround time = "+atat);  
}  
} 
//SJF
// Java program to implement Shortest Remaining Time First
// Shortest Remaining Time First (SRTF)

class Process
{
	int pid; // Process ID
	int bt; // Burst Time
	int art; // Arrival Time
	
	public Process(int pid, int bt, int art)
	{
		this.pid = pid;
		this.bt = bt;
		this.art = art;
	}
}

public class GFG
{
	static void findWaitingTime(Process proc[], int n,int wt[])
	{
		int rt[] = new int[n];
		for (int i = 0; i < n; i++)
			rt[i] = proc[i].bt;
		int complete = 0, t = 0, minm = Integer.MAX_VALUE;
		int shortest = 0, finish_time;
		boolean check = false;
		while (complete != n) {
			for (int j = 0; j < n; j++)
			{
				if ((proc[j].art <= t) &&
				(rt[j] < minm) && rt[j] > 0) {
					minm = rt[j];
					shortest = j;
					check = true;
				}
			}
			if (check == false) {
				t++;
				continue;
			}
			rt[shortest]--;
			minm = rt[shortest];
			if (minm == 0)
				minm = Integer.MAX_VALUE;
			if (rt[shortest] == 0) {
				complete++;
				check = false;
				finish_time = t + 1;
				wt[shortest] = finish_time-proc[shortest].bt-proc[shortest].art;
				if (wt[shortest] < 0)
					wt[shortest] = 0;
			}
			t++;
		}
	}
	static void findTurnAroundTime(Process proc[], int n,int wt[], int tat[])
	{
		for (int i = 0; i < n; i++)
			tat[i] = proc[i].bt + wt[i];
	}
	
	static void findavgTime(Process proc[], int n)
	{
		int wt[] = new int[n], tat[] = new int[n];
		int total_wt = 0, total_tat = 0;
		findWaitingTime(proc, n, wt);
		findTurnAroundTime(proc, n, wt, tat);
		System.out.println("Processes " +" Burst time " +" Waiting time " +" Turn around time");
		for (int i = 0; i < n; i++) {
			total_wt = total_wt + wt[i];
			total_tat = total_tat + tat[i];
			System.out.println(" " + proc[i].pid + "\t\t"+ proc[i].bt + "\t\t " + wt[i]+ "\t\t" + tat[i]);
		}
		System.out.println("Average waiting time = " +(float)total_wt / (float)n);
		System.out.println("Average turn around time = " +(float)total_tat / (float)n);
	}
	public static void main(String[] args)
	{
		Process proc[] = { new Process(1, 6, 1),
							new Process(2, 8, 1),
							new Process(3, 7, 2),
							new Process(4, 3, 3)};
		
		findavgTime(proc, proc.length);
	}
}
